import { type Audience } from "deco-sites/roast/actions/audiences/generate.ts";
import { getAssistant } from "deco-sites/roast/utils/assistants.ts";
import openai, { Run } from "deco-sites/roast/utils/openai.ts";
import { type AppContext } from "../../apps/site.ts";
import { printThread } from "deco-sites/roast/utils/debug.ts";

interface Props {
  audience: Audience;
  thread?: string;
}

export interface Being {
  name: string;
  age: number;
  personality: string;
  sign: string;
  product: string;
  dream: string;
  city: string;
  planet: string;
}

const sleep = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));

const formatAudience = (a: Audience) =>
  `${a.name}
- Age Range: ${a["age-range"]}
- Interested in: ${a.interests}
- Shopping preferences: ${a["shopping-preferences"]}
- Potential products to buy: ${a["potential-products"]}
`;

const action = async (
  props: Props,
  _req: Request,
  __ctx: AppContext,
): Promise<Being[] | null> => {
  const { audience, thread: threadId } = props;

  const assistant = await getAssistant("Roast my Commerce - Audience expert");

  const thread = threadId
    ? await openai.beta.threads.retrieve(threadId)
    : await openai.beta.threads.create();

  await openai.beta.threads.messages.create(
    thread.id,
    {
      role: "user",
      content: `I have the following audience description:\n ${
        formatAudience(audience)
      }. Generate a list of 10 fictional individuals that fit in one of these audience. The individuals are generated by calling the get_audience_individual function.`,
    },
  );

  let run = await openai.beta.threads.runs.create(thread.id, {
    assistant_id: assistant.id,
    tools: [{
      type: "function",
      function: {
        "name": "get_audience_individual",
        "description":
          "Creates a fictional individual that match a given audience",
        "parameters": {
          "type": "object",
          "properties": {
            "beings": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "name": {
                    "type": "string",
                    "description": "Full name, example: Quasara",
                  },
                  "age": {
                    "type": "number",
                    "description": "Age of the individual",
                  },
                  "personality": {
                    "type": "string",
                    "description": "Personality traits of the person",
                  },
                  "sign": {
                    "type": "string",
                    "description": "Zodiac sign: example virgo",
                  },
                  "dream": {
                    "type": "string",
                    "description":
                      "The persons life dream, e.g. Dreams about building a spaceship for enjoying the out of this world taste of space cow's milk",
                  },
                  "city": {
                    "type": "string",
                    "description": "City of birth",
                  },
                  "planet": {
                    "type": "string",
                    "description": "Name of a kepler list planet",
                  },
                  "product": {
                    "type": "string",
                    "description":
                      "Target product they'd like to buy and a storyline of why they are looking for this specific product",
                  },
                },
                "required": [
                  "name",
                  "age",
                  "personality",
                  "sign",
                  "product",
                  "dream",
                  "city",
                  "planet",
                ],
              },
            },
          },
          "required": ["beings"],
        },
      },
    }],
  });

  let beings: Being[] | null = null;
  const continueRun = (run: Run): Promise<Run> => {
    console.log(run.status);
    switch (run.status) {
      case "requires_action": {
        const calls = run.required_action?.submit_tool_outputs.tool_calls ?? [];

        for (const call of calls) {
          if (call.function.name === "get_audience_individual") {
            beings = JSON.parse(call.function.arguments)?.beings;
          }
        }

        return openai.beta.threads.runs.submitToolOutputs(
          thread.id,
          run.id,
          {
            tool_outputs: calls.map((call) => ({
              output: call.function.arguments,
              tool_call_id: call.id,
            })),
          },
        );
      }
      case "queued":
      case "in_progress":
        return openai.beta.threads.runs.retrieve(
          thread.id,
          run.id,
        );
      default:
        return Promise.resolve(run);
    }
  };

  const allowList = new Set(["queued", "in_progress", "requires_action"]);
  while (allowList.has(run.status)) {
    run = await continueRun(run);
    await sleep(1e3);
  }

  await printThread(thread.id);

  return beings;
};

const cache = await caches.open("deco-aliens");

export default async (
  props: Props,
  req: Request,
  ctx: AppContext,
): Promise<Being[] | null> => {
  try {
    const url = new URL(req.url);
    url.searchParams.set("audience", JSON.stringify(props.audience));
    url.searchParams.set("thread", props.thread ?? "");
    const cached = await cache.match(url);

    if (cached) {
      return cached.json();
    }

    const response = await action(props, req, ctx);

    cache.put(url, new Response(JSON.stringify(response)));

    return response;
  } catch (error) {
    console.error(error);
  }

  return null;
};
